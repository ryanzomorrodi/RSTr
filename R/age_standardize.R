#' Age-standardize samples
#' 
#' Consolidates a set of samples over age groups using a standard population to create age-standardized samples.
#' 
#' @param sample Array of samples generated by \code{run_sampler()}
#' @param std_pop A vector of standard populations to be used for age-standardization
#' @param margin The margin on which the groups of interest are stratified
#' @param groups A vector of either indices for each group or a vector of strings for each group name. If set to \code{NULL}, will use all groups in the dataset.
#' @param bind_new If set to \code{TRUE}, will bind to the original sample dataset using \code{abind::abind()}. Otherwise, will generate a standalone array of samples. 
#' @param new_name If binding the array to the original sample dataset, will assign a name to the new margin
#' @returns An \code{array} of age-standardized samples.
#' @examples
#' std_pop <- c(113154, 100640, 95799)
#' age_margin <- 2
#' # age-standardize by all age groups
#' samples_3564 <- age_standardize(minsample, std_pop, margin = age_margin)
#' # age-standardize only by the first two age groups
#' samples_3554 <- age_standardize(minsample, std_pop[1:2], margin = age_margin, groups = 1:2)
#' # bind age-standardized samples to original samples
#' samples_as <- age_standardize(
#'   minsample,
#'   std_pop,
#'   margin = age_margin,
#'   bind_new = TRUE,
#'   new_name = "35-64"
#' )
#' @export
age_standardize <- function(sample, std_pop, margin, groups = NULL, bind_new = FALSE, new_name = NULL) {
  mar <- seq_along(dim(sample))[-margin]
  wts <- std_pop / sum(std_pop)
  sub_sample <- sample
  if (!is.null(groups)) {
    sub_sample <- subset_array(sample, margin, groups)
  }
  if (bind_new) {
    new_dim <- dim(sample)
    new_dim[margin] <- 1
    agg_sample <- array(
      apply(sweep(sub_sample, margin, wts, "*"), mar, sum, na.rm = TRUE),
      dim <- new_dim
    )
    array_new <- abind::abind(sample, agg_sample, along = margin)
    newnames <- c(dimnames(sample)[[margin]], new_name)
    dimnames(array_new)[[margin]] <- newnames
  } else {
    array_new <- apply(sweep(sub_sample, margin, wts, "*"), mar, sum, na.rm = TRUE)
  }
  array_new
}

#' Subset array
#'
#' @noRd
subset_array <- function(array, margin, groups) {
  index_list <- lapply(dim(array), \(x) 1:x)
  index_list[[margin]] <- groups
  do.call(`[`, c(list(array), index_list))
}

#' Aggregate samples by non-age group
#' 
#' Consolidates a set of samples over non-age groups using a population array to create weighted-average samples.
#' 
#' \code{aggregate_groups()} is only meant for non-age group data, such as spatial regions, time periods, or other sociodemographic groups (race, sex, etc.). If you are interested in consolidating samples by age group, use \code{age_standardize()} instead. Additionally, if you plan on doing age-standardization along with aggregating by other groups, always aggregate groups first before doing age-standardization to ensure that the samples are properly standardized.
#' 
#' @inheritParams age_standardize
#' @param pop The population array to be used for weighted averages
#' @returns An \code{array} of weighted-average samples.
#' @examples
#' pop <- miheart$n[1:2, 1:3, 1:3]
#' time_margin <- 3
#' # calculate prevalence by aggregating over time periods
#' samples_3564 <- aggregate_groups(minsample, pop, margin = time_margin)
#' # calculate prevalence of only the first two time periods
#' samples_3554 <- aggregate_groups(minsample, pop, margin = time_margin, groups = 1:2)
#' # bind prevalence samples to original samples
#' samples_prev <- aggregate_groups(
#'   minsample,
#'   pop,
#'   margin = time_margin,
#'   bind_new = TRUE,
#'   new_name = "1979-1981"
#' )
#' @export
aggregate_groups <- function(sample, pop, margin, groups = NULL, bind_new = FALSE, new_name = NULL) {
  mar <- seq_along(dim(sample))[-margin]
  pop_arr <- array(pop, dim = c(dim(pop), rev(dim(sample))[1]))
  sub_sample <- sample
  sub_pop_arr <- pop_arr
  if (!is.null(groups)) {
    sub_sample <- subset_array(sample, margin, groups)
    sub_pop_arr <- subset_array(pop_arr, margin, groups)
  }
  if (bind_new) {
    new_dim <- dim(sample)
    new_dim[margin] <- 1
    agg_sample <- array(
      apply(sub_sample * sub_pop_arr, mar, sum, na.rm = TRUE) / apply(sub_pop_arr, mar, sum, na.rm = TRUE),
      dim <- new_dim
    )
    array_new <- abind::abind(sample, agg_sample, along = margin)
    newnames <- c(dimnames(sample)[[margin]], new_name)
    dimnames(array_new)[[margin]] <- newnames
  } else {
    array_new <- apply(sub_sample * sub_pop_arr, mar, sum, na.rm = TRUE) / apply(sub_pop_arr, mar, sum, na.rm = TRUE)
  }
  array_new
}

#' Load population array
#' 
#' Imports the population array from the model directory.
#' 
#' @inheritParams initialize_model
#' @returns The population array for the specified model.
#' @examples
#' initialize_model("test", tempdir(), miheart, miadj, .show_plots = FALSE)
#' pop = load_pop("test", tempdir())
#' 
#' # delete temp model files generated by example
#' unlink(paste0(tempdir(), "\\test"), recursive = TRUE)
#' 
#' @export
load_pop <- function(name, dir = tempdir()) {
  readRDS(paste0(dir, "/", name, "/data.Rds"))$n
}

#' Aggregate population arrays
#' 
#' @inheritParams age_standardize
#' @param pop The population array to aggregate
#' @returns An \code{array} of aggregated population data
#' @examples
#' margin_time = 3
#' # aggregate population from all years for each county-group
#' pop_7988 = aggregate_pop(miheart$n, margin_time)
#' # aggregate population from 1980-1984 for each county-group
#' pop_8084 = aggregate_pop(miheart$n, margin_time, groups = as.character(1980:1984))
#' # bind aggregated pop from all years to population data
#' pop_agg = aggregate_pop(miheart$n, margin_time, bind_new = TRUE, new_name = "1979-1988")
#' @export
aggregate_pop <- function(pop, margin, groups = NULL, bind_new = FALSE, new_name = NULL) {
  mar <- seq_along(dim(pop))[-margin]
  sub_pop <- pop
  if (!is.null(groups)) {
    sub_pop <- subset_array(pop, margin, groups)
  }
  if (bind_new) {
    
    new_dim <- dim(pop)
    new_dim[margin] <- 1
    new_pop <- array(apply(sub_pop, mar, sum, na.rm = TRUE), dim = new_dim)
    newnames <- c(dimnames(pop)[[margin]], new_name)
    array_agg <- abind::abind(pop, new_pop, along = margin)
    dimnames(array_agg)[[margin]] <- newnames
  } else {
    array_agg <- apply(sub_pop, mar, sum, na.rm = TRUE)
  }
  array_agg
}
